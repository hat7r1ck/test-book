# Import necessary libraries
import re
import pandas as pd
from IPython.display import display, HTML, Markdown, Javascript
import Levenshtein
import time

# Feature: Context-Aware Regex Suggestions (tree-based analysis for substrings, prefixes, suffixes)
def generate_optimized_regex(column_data):
    # Identify common substrings, prefixes, and suffixes using tree-based analysis
    common_prefix = common_suffix = None
    common_substrings = set(column_data.iloc[0])
    
    for value in column_data:
        common_prefix = value if common_prefix is None else common_prefix[:len(value)]
        common_suffix = value if common_suffix is None else value[len(value)-len(common_suffix):] if common_suffix else None
        common_substrings.intersection_update(set(value))

    common_substrings = sorted(common_substrings, key=len, reverse=True)
    
    # Generate an optimized regex based on findings
    regex_parts = []
    if common_prefix:
        regex_parts.append(re.escape(common_prefix))
    if common_substrings:
        regex_parts.append("|".join(map(re.escape, common_substrings)))
    if common_suffix:
        regex_parts.append(re.escape(common_suffix))
        
    optimized_pattern = "|".join(regex_parts)
    return optimized_pattern

# Feature: Regex Performance Metrics
def measure_performance(pattern, data):
    start_time = time.time()
    matches = [re.search(pattern, value) for value in data]
    end_time = time.time()
    processing_time = end_time - start_time
    match_count = sum([1 for match in matches if match])
    return {
        "processing_time": processing_time,
        "match_count": match_count,
        "coverage_percentage": (match_count / len(data)) * 100
    }

# Feature: Built-in Regex Library (common regex patterns)
built_in_regex_library = {
    "email": r"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+",
    "phone_number": r"\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}",
    "date": r"\d{4}-\d{2}-\d{2}",
    "ipv4": r"\b(?:\d{1,3}\.){3}\d{1,3}\b"
}

# Feature: Pattern History & Versioning
pattern_history = []

def save_pattern_version(pattern):
    pattern_history.append(pattern)

# Feature: Regex Debugger (step-by-step matching)
def debug_regex(pattern, data):
    for value in data:
        match = re.search(pattern, value)
        if match:
            print(f"Value: {value} --> Matched: {match.group(0)}")
        else:
            print(f"Value: {value} --> No Match")

# Feature: Dynamic Suggestions Based on Dataset Growth
def dynamic_suggestions(column_data, pattern):
    # As new data comes in, adjust regex suggestions
    new_patterns = []
    for value in column_data:
        if not re.search(pattern, value):
            new_patterns.append(value)
    return new_patterns

# Feature: Regex Compression for Large Datasets
def compress_regex(pattern):
    # Remove redundancies for large datasets
    optimized_pattern = re.sub(r'(\.\*)+', '.*', pattern)
    return optimized_pattern

# Feature: Levenshtein-based approximate matching
def levenshtein_approximate_match(data, pattern, threshold=0.8):
    matched, unmatched = [], []
    for value in data:
        ratio = Levenshtein.ratio(value, pattern)
        if ratio >= threshold:
            matched.append(value)
        else:
            unmatched.append(value)
    return matched, unmatched

# Sandbox Feature: Safe environment for testing regex patterns
def sandbox_environment(pattern, test_data):
    print("Testing Regex in Sandbox Environment:")
    debug_regex(pattern, test_data)

# Interactive buttons for pattern adjustment and copying to clipboard
def interactive_buttons(optimized_pattern):
    display(HTML(f"""
        <button onclick="applyAdjustment()">Apply Adjustment</button>
        <button onclick="copyToClipboard()">Copy Regex to Clipboard</button>
        <script>
            function applyAdjustment() {{
                var optimizedPattern = '{optimized_pattern}';
                var event = new Event('input', {{
                  bubbles: true,
                  cancelable: true,
                }});
                document.querySelector('input').value = optimizedPattern;
                document.querySelector('input').dispatchEvent(event);
            }}
            function copyToClipboard() {{
                var optimizedPattern = '{optimized_pattern}';
                navigator.clipboard.writeText(optimizedPattern);
                alert('Copied to clipboard: ' + optimizedPattern);
            }}
        </script>
    """))

# Define the main function to integrate all the functionality
def regex_tool(data, column_name, initial_pattern, threshold=0.8):
    column_data = data[column_name].astype(str)
    
    # Generate optimized regex
    optimized_pattern = generate_optimized_regex(column_data)
    
    # Save pattern version
    save_pattern_version(initial_pattern)
    
    # Measure performance
    performance_metrics = measure_performance(initial_pattern, column_data)
    
    # Provide feedback based on initial pattern
    feedback, matched, unmatched = provide_feedback(column_data, initial_pattern)
    
    # Generate interactive output
    display(Markdown(f"**Initial Pattern:** `{initial_pattern}`"))
    display(Markdown(f"**Regex Explanation:**\n{explain_regex(initial_pattern)}"))
    display(Markdown(f"**Matched Rows:** {len(matched)}"))
    display(Markdown(f"**Unmatched Rows:** {len(unmatched)}"))
    display(Markdown(f"**Feedback:** {feedback}"))
    display(Markdown(f"**Performance Metrics:**"))
    display(Markdown(f"- Processing Time: {performance_metrics['processing_time']:.4f} seconds"))
    display(Markdown(f"- Matches: {performance_metrics['match_count']}"))
    display(Markdown(f"- Coverage: {performance_metrics['coverage_percentage']:.2f}%"))
    
    # Offer regex suggestions for refinement
    display(Markdown(f"**Optimized Pattern Suggestion:** `{optimized_pattern}`"))
    display(Markdown(f"**Optimized Pattern Explanation:**\n{explain_regex(optimized_pattern)}"))
    
    # Interactive adjustment buttons
    interactive_buttons(optimized_pattern)
    
    # Levenshtein approximate matching suggestions
    if len(unmatched) > 0:
        approx_matched, approx_unmatched = levenshtein_approximate_match(unmatched, initial_pattern, threshold)
        display(Markdown(f"**Approximate Matching:**\n"))
        display(Markdown(f"Matched via Levenshtein (Threshold {threshold}): {len(approx_matched)}\n"))
        display(Markdown(f"Remaining Unmatched: {len(approx_unmatched)}"))
    
    # Sandbox feature
    sandbox_environment(initial_pattern, unmatched)

# Example Usage
# Assuming we have a DataFrame with a column 'data_column' containing text to match against
data = pd.DataFrame({
    'data_column': ["abc123", "def456", "ghi789", "abc124", "xyz987"]
})
regex_tool(data, 'data_column', r'\d{3}')
