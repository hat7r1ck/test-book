# Import necessary libraries
import re
import pandas as pd
from IPython.display import display, HTML, Markdown
import Levenshtein
import time
import ipywidgets as widgets
import io

# Placeholder for the dataframe
df = None

# CSV Upload Widget
upload_widget = widgets.FileUpload(
    accept='.csv',  # Accept CSV files
    multiple=False  # Only one file at a time
)

# Column selector widget with width adjustment for better visibility
column_selector = widgets.Dropdown(
    options=[],  # To be populated with column names after upload
    description="Select Column:",
    style={'description_width': 'initial'},
    layout=widgets.Layout(width='50%'),
    disabled=True  # Disabled until CSV is loaded
)

# Button to trigger regex tool after column selection
run_button = widgets.Button(
    description="Run Regex Tool",
    button_style='primary',
    layout=widgets.Layout(width='20%'),
    disabled=True  # Disabled until a column is selected
)

# Output area for displaying messages
output = widgets.Output()

# Function to handle the CSV upload
def handle_upload(change):
    global df
    with output:
        output.clear_output()  # Clear previous messages
        print("Processing CSV file... Please wait.")
        
        # Check if a file was uploaded
        if not upload_widget.value:
            print("No file uploaded.")
            return
        
        uploaded_file = list(upload_widget.value.values())[0]
        content = uploaded_file['content']
        
        try:
            # Read the CSV into a pandas DataFrame
            df = pd.read_csv(io.StringIO(content.decode('utf-8')))
            # Populate the column selector with the dataframe's columns
            column_selector.options = df.columns.tolist()
            column_selector.disabled = False  # Enable the column selector
            run_button.disabled = True  # Disable the run button until a column is selected
            print("CSV file loaded successfully. Columns are ready for selection.")
        except Exception as e:
            print(f"Error loading CSV file: {str(e)}")

# Attach the function to the upload widget
upload_widget.observe(handle_upload, names='value')

# Function to trigger the regex tool when the column is selected and button is clicked
def run_regex_tool(b):
    with output:
        output.clear_output()  # Clear previous messages
        if df is not None and column_selector.value:
            selected_column = column_selector.value
            print(f"Running regex tool on column: {selected_column}")
            # Call your regex_tool function here
            regex_tool(df, selected_column, r'\d{3}')
        else:
            if df is None:
                print("Please upload a valid CSV file.")
            else:
                print("Please select a column from the dropdown.")

# Attach the function to the button
run_button.on_click(run_regex_tool)

# Update the button state based on column selection
def handle_column_selection(change):
    if column_selector.value:
        run_button.disabled = False  # Enable the run button
        print(f"Column '{column_selector.value}' selected. You can now run the regex tool.")
    else:
        run_button.disabled = True

# Attach the column selection observer
column_selector.observe(handle_column_selection, names='value')

# Attach the function to the button
run_button.on_click(run_regex_tool)

# Feature: Context-Aware Regex Suggestions (tree-based analysis for substrings, prefixes, suffixes)
def generate_optimized_regex(column_data):
    # Identify common substrings, prefixes, and suffixes using tree-based analysis
    common_prefix = common_suffix = None
    common_substrings = set(column_data.iloc[0])
    
    for value in column_data:
        common_prefix = value if common_prefix is None else common_prefix[:len(value)]
        common_suffix = value if common_suffix is None else value[len(value)-len(common_suffix):] if common_suffix else None
        common_substrings.intersection_update(set(value))

    common_substrings = sorted(common_substrings, key=len, reverse=True)
    
    # Generate an optimized regex based on findings
    regex_parts = []
    if common_prefix:
        regex_parts.append(re.escape(common_prefix))
    if common_substrings:
        regex_parts.append("|".join(map(re.escape, common_substrings)))
    if common_suffix:
        regex_parts.append(re.escape(common_suffix))
        
    optimized_pattern = "|".join(regex_parts)
    return optimized_pattern

# Feature: Regex Performance Metrics
def measure_performance(pattern, data):
    start_time = time.time()
    matches = [re.search(pattern, value) for value in data]
    end_time = time.time()
    processing_time = end_time - start_time
    match_count = sum([1 for match in matches if match])
    return {
        "processing_time": processing_time,
        "match_count": match_count,
        "coverage_percentage": (match_count / len(data)) * 100
    }

# Feature: Built-in Regex Library (common regex patterns)
built_in_regex_library = {
    'Email Address': r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}',  # Matches email addresses
    'IPv4 Address': r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b',  # Matches IPv4 addresses
    'IPv6 Address': r'\b(?:[a-fA-F0-9]{1,4}:){7}[a-fA-F0-9]{1,4}\b',  # Matches IPv6 addresses
    'MAC Address': r'\b(?:[0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}\b',  # Matches MAC addresses
    'URL': r'https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+',  # Matches URLs (HTTP/HTTPS)
    'Date (YYYY-MM-DD)': r'\b\d{4}-\d{2}-\d{2}\b',  # Matches dates in the format YYYY-MM-DD
    'Time (HH:MM:SS)': r'\b\d{2}:\d{2}:\d{2}\b',  # Matches times in the format HH:MM:SS
    'File Path (Windows)': r'[a-zA-Z]:\\(?:[^\\/:*?"<>|\r\n]+\\)*[^\\/:*?"<>|\r\n]*',  # Matches Windows file paths
    'File Path (Unix)': r'\/(?:[^\/\0]+\/)*[^\/\0]*',  # Matches Unix-based file paths
    'MD5 Hash': r'\b[a-fA-F0-9]{32}\b',  # Matches MD5 hashes
    'SHA-1 Hash': r'\b[a-fA-F0-9]{40}\b',  # Matches SHA-1 hashes
    'SHA-256 Hash': r'\b[a-fA-F0-9]{64}\b',  # Matches SHA-256 hashes
    'Windows Event ID': r'\bEvent ID:\s*\d+\b',  # Matches Windows Event IDs
    'HTTP Status Code': r'\b(1\d{2}|2\d{2}|3\d{2}|4\d{2}|5\d{2})\b',  # Matches HTTP status codes (100-599)
    'User Agent String': r'[a-zA-Z\-_]+\/[\d\.]+(?:\s?\([^\)]+\))?',  # Matches user-agent strings
    'UUID/GUID': r'\b[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89ab][0-9a-fA-F]{3}-[0-9a-fA-F]{12}\b',  # Matches UUID/GUIDs
    'Port Number': r'\b\d{1,5}\b',  # Matches port numbers (1-65535)
    'Hexadecimal Value': r'\b0x[a-fA-F0-9]+\b',  # Matches hexadecimal values (e.g., 0x1A3F)
    'Windows Registry Key': r'HKEY_[A-Z_]+\\(?:[^\\/:*?"<>|\r\n]+\\)*[^\\/:*?"<>|\r\n]*',  # Matches Windows registry keys
    'Base64 String': r'\b(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{3}=|[A-Za-z0-9+\/]{2}==)?\b',  # Matches Base64 encoded strings
    'Domain Name': r'\b[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}\b',  # Matches domain names (e.g., example.com)
    'Windows Command Line Execution': r'(?:cmd\.exe|powershell\.exe|wmic\.exe|schtasks\.exe)',  # Matches common Windows command-line executions
    'PowerShell Encoded Command': r'-EncodedCommand\s+[A-Za-z0-9+/=]+',  # Matches PowerShell encoded commands
    'Credit Card Numbers': r'\b(?:\d[ -]*?){13,16}\b',  # Matches credit card numbers (13 to 16 digits)
    'US Social Security Number (SSN)': r'\b\d{3}-\d{2}-\d{4}\b',  # Matches US Social Security Numbers (SSN)
    'Docker Container ID': r'\b[a-fA-F0-9]{12}\b',  # Matches Docker container IDs (12 hex digits)
    'Windows Services Executables': r'(?:svchost\.exe|services\.exe)',  # Matches common Windows service executables
    'Sysmon Event IDs': r'\b(EventCode\s?:\s?)(?:1|10|11|12|13|14|15|17|18|19|20|21)\b',  # Matches Sysmon event IDs (EventCode: 1-21)
    'DNS Query': r'([a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}',  # Matches DNS queries (e.g., google.com)
    'Email Subject': r'Subject:\s?.+',  # Matches email subject lines
    'Apache Access Log': r'(\d{1,3}\.){3}\d{1,3}\s-\s-\s\[\d{2}\/\w+\/\d{4}:\d{2}:\d{2}:\d{2}\s\+\d{4}\]\s"GET\s\/.*?"\s\d{3}\s\d+',  # Matches Apache access log entries
}

def handle_upload(change):
    uploaded_file = list(upload_widget.value.values())[0]
    content = uploaded_file['content']
    global df
    df = pd.read_csv(pd.io.common.StringIO(content.decode('utf-8')))
    column_selector.options = df.columns
    column_selector.disabled = False

def handle_column_selection(change):
    selected_column = column_selector.value
    if selected_column:
        initial_pattern = input("Enter initial regex pattern (e.g., '\\d{3}'): ")
        regex_tool(df, selected_column, initial_pattern)

upload_widget.observe(handle_upload, names='value')
column_selector.observe(handle_column_selection, names='value')

# Feature: Pattern History & Versioning
pattern_history = []

def save_pattern_version(pattern):
    pattern_history.append(pattern)

# Feature: Regex Debugger (step-by-step matching)
def debug_regex(pattern, data):
    for value in data:
        match = re.search(pattern, value)
        if match:
            print(f"Value: {value} --> Matched: {match.group(0)}")
        else:
            print(f"Value: {value} --> No Match")

# Feature: Dynamic Suggestions Based on Dataset Growth
def dynamic_suggestions(column_data, pattern):
    # As new data comes in, adjust regex suggestions
    new_patterns = []
    for value in column_data:
        if not re.search(pattern, value):
            new_patterns.append(value)
    return new_patterns

# Feature: Regex Compression for Large Datasets
def compress_regex(pattern):
    # Remove redundancies for large datasets
    optimized_pattern = re.sub(r'(\.\*)+', '.*', pattern)
    return optimized_pattern

# Feature: Levenshtein-based approximate matching
def levenshtein_approximate_match(data, pattern, threshold=0.8):
    matched, unmatched = [], []
    for value in data:
        ratio = Levenshtein.ratio(value, pattern)
        if ratio >= threshold:
            matched.append(value)
        else:
            unmatched.append(value)
    return matched, unmatched

# Sandbox Feature: Safe environment for testing regex patterns
def sandbox_environment(pattern, test_data):
    print("Testing Regex in Sandbox Environment:")
    debug_regex(pattern, test_data)

def provide_feedback(data, pattern):
    matched = [row for row in data if re.search(pattern, row)]
    unmatched = [row for row in data if not re.search(pattern, row)]
    
    match_percentage = len(matched) / len(data) * 100
    feedback = f"Match Percentage: {match_percentage:.2f}%\n"
    
    if match_percentage < 80:
        feedback += "Suggestions:\n"
        feedback += "- Consider relaxing the pattern or using approximate matching (Levenshtein distance).\n"
    
    return feedback, matched, unmatched

def explain_regex(pattern):
    explanation = []
    if re.search(r'\d', pattern):
        explanation.append("Matches digit characters (0-9).")
    if re.search(r'\w', pattern):
        explanation.append("Matches word characters (a-z, A-Z, 0-9, _).")
    if re.search(r'\s', pattern):
        explanation.append("Matches whitespace characters.")
    if re.search(r'\b', pattern):
        explanation.append("Matches word boundaries.")
    if re.search(r'[A-Z]', pattern):
        explanation.append("Matches uppercase letters.")
    if re.search(r'[a-z]', pattern):
        explanation.append("Matches lowercase letters.")
    if re.search(r'\.', pattern):
        explanation.append("Matches any character.")
    # Add more explanations as needed
    return "\n".join(explanation)

# Interactive buttons for pattern adjustment and copying to clipboard
def interactive_buttons(optimized_pattern):
    display(HTML(f"""
        <button onclick="applyAdjustment()">Apply Adjustment</button>
        <button onclick="copyToClipboard()">Copy Regex to Clipboard</button>
        <script>
            function applyAdjustment() {{
                var optimizedPattern = '{optimized_pattern}';
                var event = new Event('input', {{
                  bubbles: true,
                  cancelable: true,
                }});
                document.querySelector('input').value = optimizedPattern;
                document.querySelector('input').dispatchEvent(event);
            }}
            function copyToClipboard() {{
                var optimizedPattern = '{optimized_pattern}';
                navigator.clipboard.writeText(optimizedPattern);
                alert('Copied to clipboard: ' + optimizedPattern);
            }}
        </script>
    """))

# Define the main function to integrate all the functionality
def regex_tool(data, column_name, initial_pattern, threshold=0.8):
    column_data = data[column_name].astype(str)
    
    # Generate optimized regex
    optimized_pattern = generate_optimized_regex(column_data)
    
    # Save pattern version
    save_pattern_version(initial_pattern)
    
    # Measure performance
    performance_metrics = measure_performance(initial_pattern, column_data)
    
    # Provide feedback based on initial pattern
    feedback, matched, unmatched = provide_feedback(column_data, initial_pattern)
    
    # Generate interactive output
    display(Markdown(f"**Initial Pattern:** `{initial_pattern}`"))
    display(Markdown(f"**Regex Explanation:**\n{explain_regex(initial_pattern)}"))
    display(Markdown(f"**Matched Rows:** {len(matched)}"))
    display(Markdown(f"**Unmatched Rows:** {len(unmatched)}"))
    display(Markdown(f"**Feedback:** {feedback}"))
    display(Markdown(f"**Performance Metrics:**"))
    display(Markdown(f"- Processing Time: {performance_metrics['processing_time']:.4f} seconds"))
    display(Markdown(f"- Matches: {performance_metrics['match_count']}"))
    display(Markdown(f"- Coverage: {performance_metrics['coverage_percentage']:.2f}%"))
    
    # Offer regex suggestions for refinement
    display(Markdown(f"**Optimized Pattern Suggestion:** `{optimized_pattern}`"))
    display(Markdown(f"**Optimized Pattern Explanation:**\n{explain_regex(optimized_pattern)}"))
    
    # Interactive adjustment buttons
    interactive_buttons(optimized_pattern)
    
    # Levenshtein approximate matching suggestions
    if len(unmatched) > 0:
        approx_matched, approx_unmatched = levenshtein_approximate_match(unmatched, initial_pattern, threshold)
        display(Markdown(f"**Approximate Matching:**\n"))
        display(Markdown(f"Matched via Levenshtein (Threshold {threshold}): {len(approx_matched)}\n"))
        display(Markdown(f"Remaining Unmatched: {len(approx_unmatched)}"))
    
    # Sandbox feature
    sandbox_environment(initial_pattern, unmatched)


# Display the widgets
display(upload_widget, column_selector, run_button, output)
