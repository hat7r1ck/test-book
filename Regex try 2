import re
import random
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

class EvolutionRegex:
    """
    Genetic Algorithm for Regex Pattern Generation.

    This class evolves regex patterns to match positive samples
    while avoiding negative samples.
    """
    def __init__(self, positive_samples, negative_samples, population_size=100, generations=100,
                 crossover_rate=0.7, mutation_rate=0.1, elitism_count=5):
        self.positive_samples = positive_samples
        self.negative_samples = negative_samples
        self.population_size = population_size
        self.generations = generations
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.elitism_count = elitism_count
        self.population = []
        self.regex_elements = self.get_regex_elements()
        self.best_pattern = ''
        self.best_fitness = -float('inf')
        self.fitness_history = []

    def get_regex_elements(self):
        # Define possible regex elements
        elements = [
            '.',        # Any character
            '\d',       # Digit
            '\D',       # Non-digit
            '\w',       # Word character
            '\W',       # Non-word character
            '\s',       # Whitespace
            '\S',       # Non-whitespace
            '[a-z]',    # Lowercase letters
            '[A-Z]',    # Uppercase letters
            '[a-zA-Z]', # All letters
            '[0-9]',    # Digits 0-9
            '[^a-zA-Z0-9]', # Special characters
            # Add more character classes or literals as needed
        ]
        # Add escaped literals from positive samples
        literals = set()
        for sample in self.positive_samples:
            for char in sample:
                literals.add(re.escape(char))
        elements.extend(literals)
        return list(elements)

    def initialize_population(self):
        # Generate initial population of random regex patterns
        for _ in range(self.population_size):
            pattern_length = random.randint(3, 10)
            pattern = ''.join(random.choices(self.regex_elements, k=pattern_length))
            self.population.append(pattern)

    def fitness(self, pattern):
        try:
            regex = re.compile(pattern)
        except re.error:
            return -float('inf')  # Invalid regex patterns are least fit

        tp = sum(bool(regex.search(s)) for s in self.positive_samples)
        fp = sum(bool(regex.search(s)) for s in self.negative_samples)

        tpr = tp / len(self.positive_samples) if self.positive_samples else 0
        fpr = fp / len(self.negative_samples) if self.negative_samples else 0

        # Fitness function balancing TPR and FPR
        fitness_score = tpr - fpr

        # Penalize overly general patterns
        if fpr > 0:
            fitness_score -= fpr

        # Prefer shorter patterns
        fitness_score -= len(pattern) * 0.01

        return fitness_score

    def selection(self):
        # Roulette Wheel Selection
        fitness_scores = [self.fitness(p) for p in self.population]
        min_fitness = min(fitness_scores)
        adjusted_fitness = [f - min_fitness + 1 for f in fitness_scores]  # Avoid negative values
        total_fitness = sum(adjusted_fitness)
        if total_fitness == 0:
            # If all fitness scores are equal, select randomly
            return random.choices(self.population, k=self.population_size)
        selection_probs = [f / total_fitness for f in adjusted_fitness]

        selected = random.choices(self.population, weights=selection_probs, k=self.population_size)
        return selected

    def crossover(self, parent1, parent2):
        # Single-point crossover
        if random.random() < self.crossover_rate and min(len(parent1), len(parent2)) > 1:
            point = random.randint(1, min(len(parent1), len(parent2)) - 1)
            child1 = parent1[:point] + parent2[point:]
            child2 = parent2[:point] + parent1[point:]
            return [child1, child2]
        else:
            return [parent1, parent2]

    def mutate(self, pattern):
        # Random mutation
        pattern_list = list(pattern)
        for i in range(len(pattern_list)):
            if random.random() < self.mutation_rate:
                pattern_list[i] = random.choice(self.regex_elements)
        # Randomly insert or delete elements
        if random.random() < self.mutation_rate:
            if random.random() < 0.5 and len(pattern_list) > 1:
                # Delete a random element
                del pattern_list[random.randint(0, len(pattern_list) - 1)]
            else:
                # Insert a random element
                pattern_list.insert(random.randint(0, len(pattern_list)), random.choice(self.regex_elements))
        return ''.join(pattern_list)

    def run(self):
        self.initialize_population()
        for generation in range(self.generations):
            new_population = []

            # Evaluate fitness and keep the best patterns (elitism)
            population_fitness = [(p, self.fitness(p)) for p in self.population]
            population_fitness.sort(key=lambda x: x[1], reverse=True)
            self.fitness_history.append(population_fitness[0][1])
            if population_fitness[0][1] > self.best_fitness:
                self.best_fitness = population_fitness[0][1]
                self.best_pattern = population_fitness[0][0]

            elites = [p for p, _ in population_fitness[:self.elitism_count]]
            new_population.extend(elites)

            # Selection
            selected = self.selection()

            # Generate new population through crossover and mutation
            while len(new_population) < self.population_size:
                parents = random.sample(selected, 2)
                offspring = self.crossover(parents[0], parents[1])
                offspring = [self.mutate(child) for child in offspring]
                new_population.extend(offspring)

            self.population = new_population[:self.population_size]

            # Optional: Print progress
            print(f"Generation {generation + 1}/{self.generations}, Best Fitness: {self.best_fitness:.4f}", end='\r')

        return self.best_pattern

# Function to read CSV file and process data
def load_data(file_path, data_column_name, label_column_name, positive_label_value):
    try:
        df = pd.read_csv(file_path)
        data_column = df[data_column_name].astype(str)
        labels = df[label_column_name].astype(str)
        positive_samples = data_column[labels == positive_label_value].tolist()
        negative_samples = data_column[labels != positive_label_value].tolist()

        if not positive_samples:
            print(f"No positive samples found with label: {positive_label_value}")
            print("Please ensure your label column contains the correct label value.")
            unique_labels = labels.unique()
            print(f"Unique label values found: {unique_labels}")
            return None, None

        return positive_samples, negative_samples
    except Exception as e:
        print(f"Error loading data: {e}")
        return None, None

# User inputs
# Option 1: Using input prompts
# file_path = input("Enter the path to your CSV file (e.g., data.csv): ").strip()
# data_column_name = input("Enter the name of your data column: ").strip()
# label_column_name = input("Enter the name of your label column: ").strip()
# positive_label_value = input("Enter the label value for positive samples (e.g., 1 or True): ").strip()

# Option 2: Setting variables directly
file_path = 'data.csv'  # Replace with your file path
data_column_name = 'Message'  # Replace with your data column name
label_column_name = 'Label'    # Replace with your label column name
positive_label_value = '1'     # Replace with your positive label value

# Load data
positive_samples, negative_samples = load_data(file_path, data_column_name, label_column_name, positive_label_value)
if positive_samples is None:
    print("Data loading failed. Please check your inputs.")
else:
    print(f"Positive samples: {len(positive_samples)}")
    print(f"Negative samples: {len(negative_samples)}")

# Initialize and run the genetic algorithm
ga = EvolutionRegex(
    positive_samples=positive_samples,
    negative_samples=negative_samples,
    population_size=200,
    generations=200,
    crossover_rate=0.8,
    mutation_rate=0.2,
    elitism_count=10
)

print("\nRunning the regex generator. Please wait...")
best_pattern = ga.run()
regex_pattern = best_pattern

# Evaluate final pattern
try:
    regex = re.compile(regex_pattern)
except re.error as e:
    print(f"Error compiling the final regex pattern: {e}")
    regex = None

if regex:
    tp = sum(bool(regex.search(s)) for s in positive_samples)
    fp = sum(bool(regex.search(s)) for s in negative_samples)
    fn = len(positive_samples) - tp
    tn = len(negative_samples) - fp

    tpr = tp / len(positive_samples) if positive_samples else 0
    fpr = fp / len(negative_samples) if negative_samples else 0

    print("\n=== Generated Regex Pattern ===")
    print(f"{regex_pattern}")
    print(f"Pattern Length: {len(regex_pattern)}")

    print("\n=== Performance Metrics ===")
    print(f"True Positives (TP): {tp}")
    print(f"False Positives (FP): {fp}")
    print(f"True Negatives (TN): {tn}")
    print(f"False Negatives (FN): {fn}")
    print(f"True Positive Rate (TPR): {tpr:.4f}")
    print(f"False Positive Rate (FPR): {fpr:.4f}")

    # Display matched and unmatched samples
    matched_positives = [s for s in positive_samples if regex.search(s)]
    matched_negatives = [s for s in negative_samples if regex.search(s)]

    print("\n=== Examples of Positive Samples Matched ===")
    for sample in matched_positives[:5]:
        print(sample)

    if matched_negatives:
        print("\n=== Examples of Negative Samples Matched (False Positives) ===")
        for sample in matched_negatives[:5]:
            print(sample)
    else:
        print("\nNo false positives detected.")
else:
    print("Failed to compile the regex pattern.")

# Optional: Plot fitness over generations
plt.plot(ga.fitness_history)
plt.title('Fitness over Generations')
plt.xlabel('Generation')
plt.ylabel('Fitness')
plt.show()
