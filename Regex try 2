# Import necessary libraries
import re
import pandas as pd
from IPython.display import display, HTML, Markdown
import Levenshtein
import time
import ipywidgets as widgets
import io
from os import path
from difflib import SequenceMatcher
from ipyfilechooser import FileChooser
import string

# Placeholder for the DataFrame
df = None

# File chooser widget
file_chooser = FileChooser(
    use_dir_icons=True,
    filter_pattern='*.csv',
    show_only_dirs=False
)

# Button to load CSV
load_button = widgets.Button(
    description="Load CSV",
    button_style='primary',
    layout=widgets.Layout(width='20%'),
)

# Column selector widget with width adjustment for better visibility
column_selector = widgets.Dropdown(
    options=[],  # To be populated with column names after loading CSV
    description="Select Column:",
    style={'description_width': 'initial'},
    layout=widgets.Layout(width='50%'),
    disabled=True  # Disabled until CSV is loaded
)

# Regex Library Selector
regex_library_selector = widgets.Dropdown(
    options=['-- Select from Library --'],  # Will be populated later
    description="Regex Library (Optional):",
    style={'description_width': 'initial'},
    layout=widgets.Layout(width='50%'),
)

# Text input widget for the regex pattern
regex_input = widgets.Text(
    value='',
    description='Custom Regex Pattern (Optional):',
    style={'description_width': 'initial'},
    layout=widgets.Layout(width='50%'),
)

# Button to trigger the regex tool
run_button = widgets.Button(
    description="Run Regex Tool",
    button_style='success',
    layout=widgets.Layout(width='20%'),
    disabled=True  # Will be enabled after column selection
)

# Output area for displaying messages
output = widgets.Output()

# Display the widgets
display(file_chooser)
display(load_button)
display(column_selector)
display(Markdown("**Optional:** You may provide a custom regex pattern or select one from the library..."))
display(regex_library_selector)
display(regex_input)
display(run_button)
display(output)

# Feature: Built-in Regex Library (common regex patterns)
built_in_regex_library = {
    'Email Address': r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}',  # Matches email addresses
    'IPv4 Address': r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b',  # Matches IPv4 addresses
    'IPv6 Address': r'\b(?:[a-fA-F0-9]{1,4}:){7}[a-fA-F0-9]{1,4}\b',  # Matches IPv6 addresses
    'MAC Address': r'\b(?:[0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}\b',  # Matches MAC addresses
    'URL': r'https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+',  # Matches URLs (HTTP/HTTPS)
    'Date (YYYY-MM-DD)': r'\b\d{4}-\d{2}-\d{2}\b',  # Matches dates in the format YYYY-MM-DD
    'Time (HH:MM:SS)': r'\b\d{2}:\d{2}:\d{2}\b',  # Matches times in the format HH:MM:SS
    'File Path (Windows)': r'[a-zA-Z]:\\(?:[^\\/:*?"<>|\r\n]+\\)*[^\\/:*?"<>|\r\n]*',  # Matches Windows file paths
    'File Path (Unix)': r'\/(?:[^\/\0]+\/)*[^\/\0]*',  # Matches Unix-based file paths
    'MD5 Hash': r'\b[a-fA-F0-9]{32}\b',  # Matches MD5 hashes
    'SHA-1 Hash': r'\b[a-fA-F0-9]{40}\b',  # Matches SHA-1 hashes
    'SHA-256 Hash': r'\b[a-fA-F0-9]{64}\b',  # Matches SHA-256 hashes
    'Windows Event ID': r'\bEvent ID:\s*\d+\b',  # Matches Windows Event IDs
    'HTTP Status Code': r'\b(1\d{2}|2\d{2}|3\d{2}|4\d{2}|5\d{2})\b',  # Matches HTTP status codes (100-599)
    'User Agent String': r'[a-zA-Z\-_]+\/[\d\.]+(?:\s?\([^\)]+\))?',  # Matches user-agent strings
    'UUID/GUID': r'\b[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89ab][0-9a-fA-F]{3}-[0-9a-fA-F]{12}\b',  # Matches UUID/GUIDs
    'Port Number': r'\b\d{1,5}\b',  # Matches port numbers (1-65535)
    'Hexadecimal Value': r'\b0x[a-fA-F0-9]+\b',  # Matches hexadecimal values (e.g., 0x1A3F)
    'Windows Registry Key': r'HKEY_[A-Z_]+\\(?:[^\\/:*?"<>|\r\n]+\\)*[^\\/:*?"<>|\r\n]*',  # Matches Windows registry keys
    'Base64 String': r'\b(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{3}=|[A-Za-z0-9+\/]{2}==)?\b',  # Matches Base64 encoded strings
    'Domain Name': r'\b[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}\b',  # Matches domain names (e.g., example.com)
    'Windows Command Line Execution': r'(?:cmd\.exe|powershell\.exe|wmic\.exe|schtasks\.exe)',  # Matches common Windows command-line executions
    'PowerShell Encoded Command': r'-EncodedCommand\s+[A-Za-z0-9+/=]+',  # Matches PowerShell encoded commands
    'Credit Card Numbers': r'\b(?:\d[ -]*?){13,16}\b',  # Matches credit card numbers (13 to 16 digits)
    'US Social Security Number (SSN)': r'\b\d{3}-\d{2}-\d{4}\b',  # Matches US Social Security Numbers (SSN)
    'Docker Container ID': r'\b[a-fA-F0-9]{12}\b',  # Matches Docker container IDs (12 hex digits)
    'Windows Services Executables': r'(?:svchost\.exe|services\.exe)',  # Matches common Windows service executables
    'Sysmon Event IDs': r'\b(EventCode\s?:\s?)(?:1|10|11|12|13|14|15|17|18|19|20|21)\b',  # Matches Sysmon event IDs (EventCode: 1-21)
    'DNS Query': r'([a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}',  # Matches DNS queries (e.g., google.com)
    'Email Subject': r'Subject:\s?.+',  # Matches email subject lines
    'Apache Access Log': r'(\d{1,3}\.){3}\d{1,3}\s-\s-\s\[\d{2}\/\w+\/\d{4}:\d{2}:\d{2}:\d{2}\s\+\d{4}\]\s"GET\s\/.*?"\s\d{3}\s\d+',  # Matches Apache access log entries
}

# Update regex_library_selector options
regex_library_selector.options = ['-- Select from Library --'] + list(built_in_regex_library.keys())

# Function to update regex_input based on library selection
def handle_regex_library_selection(change):
    if regex_library_selector.value != '-- Select from Library --':
        regex_input.value = built_in_regex_library[regex_library_selector.value]
    else:
        regex_input.value = ''

regex_library_selector.observe(handle_regex_library_selection, names='value')

# Function to load CSV from selected file
def load_csv(b):
    global df
    with output:
        output.clear_output()
        file_path = file_chooser.selected
        if not file_path:
            display("Please select a CSV file.")
            return
        try:
            display(f"Loading CSV file from: {file_path}")
            df = pd.read_csv(file_path)
            display("CSV file content preview:")
            # Display the DataFrame in a scrollable output
            from IPython.display import HTML

            # Convert the DataFrame to HTML with scrollable styling
            def display_scrollable_dataframe(df):
                html = df.to_html()
                scrollable_div = f'''
                <div style="overflow-x: auto; max-width: 100%;">
                    {html}
                </div>
                '''
                display(HTML(scrollable_div))

            display_scrollable_dataframe(df.head())  # Show a preview of the DataFrame
            # Populate the column selector with the DataFrame's columns
            column_selector.options = df.columns.tolist()
            column_selector.disabled = False  # Enable the column selector
            run_button.disabled = True  # Disable the run button until a column is selected
            display("CSV file loaded successfully. Select a column from the dropdown.")
        except Exception as e:
            display(f"Error loading CSV file: {str(e)}")

# Attach the function to the load button
load_button.on_click(load_csv)

# Update the button state based on column selection
def handle_column_selection(change):
    with output:
        output.clear_output()
        if column_selector.value:
            run_button.disabled = False  # Enable the run button
            display(f"Column '{column_selector.value}' selected. You can now run the regex tool.")
        else:
            run_button.disabled = True

# Attach the column selection observer
column_selector.observe(handle_column_selection, names='value')

# Feature: Pattern History & Versioning
pattern_history = []

def save_pattern_version(pattern):
    pattern_history.append(pattern)

# Function to explain regex patterns
def explain_regex(pattern):
    explanation = []
    # Simple explanations for basic regex components
    if '^' in pattern:
        explanation.append("Matches the start of the string.")
    if '$' in pattern:
        explanation.append("Matches the end of the string.")
    if r'\d' in pattern:
        explanation.append("Matches any digit (0-9).")
    if r'\w' in pattern:
        explanation.append("Matches any word character (letters, digits, underscore).")
    if r'\s' in pattern:
        explanation.append("Matches any whitespace character.")
    if '.' in pattern:
        explanation.append("Matches any character except newline.")
    if '+' in pattern:
        explanation.append("Matches 1 or more of the preceding element.")
    if '*' in pattern:
        explanation.append("Matches 0 or more of the preceding element.")
    if '?' in pattern:
        explanation.append("Matches 0 or 1 of the preceding element.")
    if '[' in pattern and ']' in pattern:
        explanation.append("Character class: matches any one of the characters inside the brackets.")
    if '{' in pattern and '}' in pattern:
        explanation.append("Quantifier: matches a specified number of occurrences of the preceding element.")
    # Add more explanations as needed
    return "\n".join(explanation)

# Feature: Levenshtein-based approximate matching
def levenshtein_approximate_match(data, pattern, threshold=0.8):
    matched, unmatched = [], []
    for value in data:
        distance = Levenshtein.distance(value, pattern)
        max_len = max(len(value), len(pattern))
        similarity = 1 - (distance / max_len) if max_len > 0 else 0
        if similarity >= threshold:
            matched.append(value)
        else:
            unmatched.append(value)
    return matched, unmatched

# Sandbox Feature: Safe environment for testing regex patterns
def sandbox_environment(pattern, test_data):
    display(Markdown("**Testing Regex in Sandbox Environment:**"))
    for value in test_data[:5]:  # Limit output to first 5 entries
        match = re.search(pattern, value)
        if match:
            display(f"Value: {value} --> Matched: {match.group(0)}")
        else:
            display(f"Value: {value} --> No Match")

def provide_feedback(data, pattern):
    matched = [row for row in data if re.fullmatch(pattern, row)]
    unmatched = [row for row in data if not re.fullmatch(pattern, row)]

    match_percentage = len(matched) / len(data) * 100 if data else 0
    feedback = f"Match Percentage: {match_percentage:.2f}%\n"

    if match_percentage < 80:
        feedback += "Suggestions:\n"
        feedback += "- Consider refining the pattern or reviewing unmatched data for inconsistencies.\n"

    return feedback, matched, unmatched

# Interactive buttons for pattern adjustment and copying to clipboard
def interactive_buttons(optimized_pattern):
    display(Markdown(f"**Regex Pattern:** `{optimized_pattern}`"))
    # Provide alternative instructions if the button doesn't work
    display(Markdown("Copy the regex pattern manually if the button doesn't work."))

# Enhanced regex generator function
def generate_smart_regex(column_data):
    unique_values = [s for s in set(column_data) if s]
    if not unique_values:
        return '.*'  # Return a generic pattern if data is empty

    # Find minimum and maximum string lengths
    min_len = min(len(s) for s in unique_values)
    max_len = max(len(s) for s in unique_values)

    # Initialize pattern components
    pattern_parts = []

    for i in range(max_len):
        chars_at_pos = set()
        for s in unique_values:
            if i < len(s):
                chars_at_pos.add(s[i])
            else:
                chars_at_pos.add(None)

        chars_at_pos.discard(None)
        if not chars_at_pos:
            # Position exceeds all string lengths
            break

        if len(chars_at_pos) == 1:
            # Fixed character
            char = chars_at_pos.pop()
            pattern_parts.append(re.escape(char))
        else:
            # Variable character, determine character class
            char_class = ''

            if all(c.isdigit() for c in chars_at_pos):
                char_class = r'\d'
            elif all(c.isalpha() for c in chars_at_pos):
                if all(c.islower() for c in chars_at_pos):
                    char_class = r'[a-z]'
                elif all(c.isupper() for c in chars_at_pos):
                    char_class = r'[A-Z]'
                else:
                    char_class = r'[a-zA-Z]'
            elif all(c in string.punctuation for c in chars_at_pos):
                # Special characters
                escaped_chars = ''.join(re.escape(c) for c in chars_at_pos)
                char_class = f'[{escaped_chars}]'
            else:
                # Mixed character types
                escaped_chars = ''.join(re.escape(c) for c in chars_at_pos)
                char_class = f'[{escaped_chars}]'

            pattern_parts.append(char_class)

    # Handle variable string lengths
    if min_len != max_len:
        # Add optional pattern parts
        pattern = ''
        for idx, part in enumerate(pattern_parts):
            if all(len(s) > idx for s in unique_values):
                pattern += part
            else:
                pattern += f'(?:{part})?'
    else:
        pattern = ''.join(pattern_parts)

    # Add anchors
    pattern = '^' + pattern + '$'

    return pattern

# Define the main function to integrate all the functionality
def regex_tool(data, column_name, user_pattern=None, threshold=0.8):
    column_data = data[column_name].astype(str)

    # Generate the regex pattern using the improved function
    auto_generated_pattern = generate_smart_regex(column_data)

    # Determine which pattern to use
    if user_pattern:
        initial_pattern = user_pattern
        pattern_source = "User-provided pattern"
    else:
        initial_pattern = auto_generated_pattern
        pattern_source = "Automatically generated pattern"

    # Save pattern version
    save_pattern_version(initial_pattern)

    # Measure performance
    performance_metrics = measure_performance(initial_pattern, column_data)

    # Provide feedback based on initial pattern
    feedback, matched, unmatched = provide_feedback(column_data, initial_pattern)

    # Generate interactive output
    display(Markdown(f"**{pattern_source}:** `{initial_pattern}`"))
    display(Markdown(f"**Regex Explanation:**\n{explain_regex(initial_pattern)}"))
    display(Markdown(f"**Matched Rows:** {len(matched)}"))
    display(Markdown(f"**Unmatched Rows:** {len(unmatched)}"))
    display(Markdown(f"**Feedback:**\n{feedback}"))
    display(Markdown(f"**Performance Metrics:**"))
    display(Markdown(f"- Processing Time: {performance_metrics['processing_time']:.4f} seconds"))
    display(Markdown(f"- Matches: {performance_metrics['match_count']}"))
    display(Markdown(f"- Coverage: {performance_metrics['coverage_percentage']:.2f}%"))

    # If a user pattern was provided, offer the auto-generated pattern as a suggestion
    if user_pattern:
        display(Markdown(f"**Auto-Generated Pattern Suggestion:** `{auto_generated_pattern}`"))
        display(Markdown(f"**Auto-Generated Pattern Explanation:**\n{explain_regex(auto_generated_pattern)}"))
        # Interactive adjustment buttons
        interactive_buttons(auto_generated_pattern)
    else:
        # Interactive adjustment buttons
        interactive_buttons(initial_pattern)

    # Levenshtein approximate matching suggestions
    if len(unmatched) > 0:
        approx_matched, approx_unmatched = levenshtein_approximate_match(unmatched, initial_pattern, threshold)
        display(Markdown(f"**Approximate Matching:**\n"))
        display(Markdown(f"Matched via Levenshtein (Threshold {threshold}): {len(approx_matched)}\n"))
        display(Markdown(f"Remaining Unmatched: {len(approx_unmatched)}"))

    # Sandbox feature
    sandbox_environment(initial_pattern, unmatched)

# Function to measure regex performance
def measure_performance(pattern, data):
    start_time = time.time()
    try:
        compiled_pattern = re.compile(pattern)
        matches = [compiled_pattern.fullmatch(value) for value in data]
    except re.error as e:
        end_time = time.time()
        return {
            "processing_time": end_time - start_time,
            "match_count": 0,
            "coverage_percentage": 0,
            "error": str(e)
        }
    end_time = time.time()
    processing_time = end_time - start_time
    match_count = sum(1 for match in matches if match)
    return {
        "processing_time": processing_time,
        "match_count": match_count,
        "coverage_percentage": (match_count / len(data)) * 100 if data else 0
    }

# Function to trigger the regex tool when the button is clicked
def run_regex_tool(b):
    with output:
        output.clear_output()  # Clear previous messages
        try:
            if df is not None and column_selector.value:
                selected_column = column_selector.value
                display(f"Running regex tool on column: {selected_column}")

                user_pattern = None
                if regex_input.value.strip():
                    user_pattern = regex_input.value.strip()
                elif regex_library_selector.value != '-- Select from Library --':
                    user_pattern = regex_input.value.strip()

                regex_tool(df, selected_column, user_pattern)
            else:
                if df is None:
                    display("Please load a valid CSV file.")
                else:
                    display("Please select a column from the dropdown.")
        except Exception as e:
            display(f"An error occurred: {str(e)}")

# Attach the function to the run button
run_button.on_click(run_regex_tool)
