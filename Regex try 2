# Import necessary libraries
import re
import pandas as pd
from IPython.display import display, HTML
import ipywidgets as widgets
from ipyfilechooser import FileChooser
from collections import defaultdict
import itertools

# Placeholder for the DataFrame
df = None

# Define styles for better visibility
style = {'description_width': 'initial'}
layout = widgets.Layout(width='50%')
button_layout = widgets.Layout(width='20%')
button_style = 'primary'

# File chooser widget
file_chooser = FileChooser(
    use_dir_icons=True,
    filter_pattern='*.csv',
    show_only_dirs=False
)

# Button to load CSV
load_button = widgets.Button(
    description="Load CSV",
    layout=button_layout,
    button_style=button_style
)

# Column selector widget
column_selector = widgets.Dropdown(
    options=[],  # To be populated with column names after loading CSV
    description="Select Column:",
    style=style,
    layout=layout,
    disabled=True  # Disabled until CSV is loaded
)

# Regex Library Selector
regex_library_selector = widgets.Dropdown(
    options=['-- Select from Library --'],  # Will be populated later
    description="Regex Library (Optional):",
    style=style,
    layout=layout,
)

# Text input widget for the regex pattern
regex_input = widgets.Text(
    value='',
    description='Custom Regex Pattern (Optional):',
    style=style,
    layout=layout,
)

# Button to trigger the regex tool
run_button = widgets.Button(
    description="Run Regex Tool",
    layout=button_layout,
    button_style='success'
)

# Output area for displaying messages
output = widgets.Output()

# Instructional text
optional_text = widgets.Label(
    "Optional: You may provide a custom regex pattern or select one from the library..."
)

# Display the widgets in a vertical box
display(widgets.VBox([
    file_chooser,
    load_button,
    column_selector,
    optional_text,
    regex_library_selector,
    regex_input,
    run_button,
    output
]))

# Feature: Built-in Regex Library (common regex patterns)
built_in_regex_library = {
    'Email Address': r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}',
    # Add more patterns as needed
}

# Update regex_library_selector options
regex_library_selector.options = ['-- Select from Library --'] + list(built_in_regex_library.keys())

# Function to update regex_input based on library selection
def handle_regex_library_selection(change):
    if regex_library_selector.value != '-- Select from Library --':
        regex_input.value = built_in_regex_library[regex_library_selector.value]
    else:
        regex_input.value = ''

regex_library_selector.observe(handle_regex_library_selection, names='value')

# Function to load CSV from selected file
def load_csv(b):
    global df
    with output:
        output.clear_output()
        file_path = file_chooser.selected
        if not file_path:
            display("Please select a CSV file.")
            return
        try:
            display(f"Loading CSV file from: {file_path}")
            df = pd.read_csv(file_path)
            display("CSV file content preview:")
            def display_scrollable_dataframe(df):
                html = df.to_html()
                scrollable_div = f'''
                <div style="overflow-x: auto; max-width: 100%;">
                    {html}
                </div>
                '''
                display(HTML(scrollable_div))

            display_scrollable_dataframe(df.head())  # Show a preview of the DataFrame
            # Populate the column selector with the DataFrame's columns
            column_selector.options = df.columns.tolist()
            column_selector.disabled = False  # Enable the column selector
            run_button.disabled = True  # Disable the run button until a column is selected
            display("CSV file loaded successfully. Select a column from the dropdown.")
        except Exception as e:
            display(f"Error loading CSV file: {str(e)}")

# Attach the function to the load button
load_button.on_click(load_csv)

# Update the button state based on column selection
def handle_column_selection(change):
    with output:
        output.clear_output()
        if column_selector.value:
            run_button.disabled = False  # Enable the run button
            display(f"Column '{column_selector.value}' selected. You can now run the regex tool.")
        else:
            run_button.disabled = True

# Attach the column selection observer
column_selector.observe(handle_column_selection, names='value')

# Function to infer regex pattern from examples using pairwise alignment
def infer_regex_from_examples(examples):
    # Use pairwise alignment to find common patterns
    def longest_common_subsequence(s1, s2):
        m = len(s1)
        n = len(s2)
        dp = [["" for x in range(n+1)] for x in range(m+1)]
        for i in range(m):
            for j in range(n):
                if s1[i] == s2[j]:
                    dp[i+1][j+1] = dp[i][j] + s1[i]
                else:
                    dp[i+1][j+1] = dp[i+1][j] if len(dp[i+1][j]) > len(dp[i][j+1]) else dp[i][j+1]
        return dp[m][n]

    # Start with the first example
    common_subseq = examples[0]
    for example in examples[1:]:
        common_subseq = longest_common_subsequence(common_subseq, example)
        if not common_subseq:
            break

    if not common_subseq:
        # If there's no common subsequence, fallback to generic pattern
        min_len = min(len(s) for s in examples)
        max_len = max(len(s) for s in examples)
        return '^.{%d,%d}$' % (min_len, max_len)

    # Build regex pattern by replacing variable parts with appropriate patterns
    regex_parts = []
    last_pos = 0
    for match in re.finditer(re.escape(common_subseq), examples[0]):
        start, end = match.span()
        # Variable part before the match
        if start > last_pos:
            var_part = examples[0][last_pos:start]
            regex_parts.append(pattern_for_variable_part(var_part, examples, last_pos, start))
        # Fixed part (common subsequence)
        regex_parts.append(re.escape(examples[0][start:end]))
        last_pos = end
    # Variable part after the last match
    if last_pos < len(examples[0]):
        var_part = examples[0][last_pos:]
        regex_parts.append(pattern_for_variable_part(var_part, examples, last_pos, len(examples[0])))

    pattern = '^' + ''.join(regex_parts) + '$'
    return pattern

def pattern_for_variable_part(fixed_part, examples, start_idx, end_idx):
    # Analyze the variable part across all examples
    var_parts = [s[start_idx:end_idx] for s in examples]
    if all(part.isdigit() for part in var_parts):
        # All digits
        lengths = [len(part) for part in var_parts]
        if min(lengths) == max(lengths):
            return r'\d{' + str(lengths[0]) + '}'
        else:
            return r'\d{' + str(min(lengths)) + ',' + str(max(lengths)) + '}'
    elif all(part.isalpha() for part in var_parts):
        # All letters
        lengths = [len(part) for part in var_parts]
        if min(lengths) == max(lengths):
            return r'[a-zA-Z]{' + str(lengths[0]) + '}'
        else:
            return r'[a-zA-Z]{' + str(min(lengths)) + ',' + str(max(lengths)) + '}'
    elif all(part.isalnum() for part in var_parts):
        # Alphanumeric
        lengths = [len(part) for part in var_parts]
        if min(lengths) == max(lengths):
            return r'\w{' + str(lengths[0]) + '}'
        else:
            return r'\w{' + str(min(lengths)) + ',' + str(max(lengths)) + '}'
    else:
        # Mixed characters
        lengths = [len(part) for part in var_parts]
        return r'.{' + str(min(lengths)) + ',' + str(max(lengths)) + '}'

# Define the main function to integrate all the functionality
def regex_tool(data, column_name, user_pattern=None, threshold=0.8):
    column_data = data[column_name].astype(str).tolist()

    # Generate the regex pattern using the advanced function
    auto_generated_pattern = infer_regex_from_examples(column_data)

    # Determine which pattern to use
    if user_pattern:
        initial_pattern = user_pattern
        pattern_source = "User-provided pattern"
    else:
        initial_pattern = auto_generated_pattern
        pattern_source = "Automatically generated pattern"

    # Provide feedback based on initial pattern
    feedback, matched, unmatched = provide_feedback(column_data, initial_pattern)

    # Generate interactive output
    display(f"**{pattern_source}:** `{initial_pattern}`")
    display(f"**Regex Explanation:**\n{explain_regex(initial_pattern)}")
    display(f"**Matched Rows:** {len(matched)}")
    display(f"**Unmatched Rows:** {len(unmatched)}")
    display(f"**Feedback:**\n{feedback}")

    # If a user pattern was provided, offer the auto-generated pattern as a suggestion
    if user_pattern:
        display(f"**Auto-Generated Pattern Suggestion:** `{auto_generated_pattern}`")
        display(f"**Auto-Generated Pattern Explanation:**\n{explain_regex(auto_generated_pattern)}")
        interactive_buttons(auto_generated_pattern)
    else:
        interactive_buttons(initial_pattern)

    # Sandbox feature
    if len(unmatched) > 0:
        sandbox_environment(initial_pattern, unmatched)

# Function to measure regex performance
def measure_performance(pattern, data):
    start_time = time.time()
    try:
        compiled_pattern = re.compile(pattern)
        matches = [compiled_pattern.fullmatch(value) for value in data]
    except re.error as e:
        end_time = time.time()
        return {
            "processing_time": end_time - start_time,
            "match_count": 0,
            "coverage_percentage": 0,
            "error": str(e)
        }
    end_time = time.time()
    processing_time = end_time - start_time
    match_count = sum(1 for match in matches if match)
    coverage_percentage = (match_count / len(data)) * 100 if len(data) > 0 else 0
    return {
        "processing_time": processing_time,
        "match_count": match_count,
        "coverage_percentage": coverage_percentage
    }

# Function to provide feedback
def provide_feedback(data, pattern):
    matched = [row for row in data if re.fullmatch(pattern, row)]
    unmatched = [row for row in data if not re.fullmatch(pattern, row)]

    match_percentage = len(matched) / len(data) * 100 if len(data) > 0 else 0
    feedback = f"Match Percentage: {match_percentage:.2f}%\n"

    if match_percentage < 80:
        feedback += "Suggestions:\n"
        feedback += "- Consider refining the pattern or reviewing unmatched data for inconsistencies.\n"

    return feedback, matched, unmatched

# Interactive buttons for pattern adjustment and copying to clipboard
def interactive_buttons(optimized_pattern):
    display(f"**Regex Pattern:** `{optimized_pattern}`")
    display("Copy the regex pattern manually if needed.")

# Sandbox Feature: Safe environment for testing regex patterns
def sandbox_environment(pattern, test_data):
    display("**Testing Regex in Sandbox Environment:**")
    for value in test_data[:5]:  # Limit output to first 5 entries
        match = re.fullmatch(pattern, value)
        if match:
            display(f"Value: {value} --> Matched: {match.group(0)}")
        else:
            display(f"Value: {value} --> No Match")

# Function to trigger the regex tool when the button is clicked
def run_regex_tool(b):
    with output:
        output.clear_output()
        try:
            if df is not None and column_selector.value:
                selected_column = column_selector.value
                column_data = df[selected_column].astype(str)
                display(f"Running regex tool on column: {selected_column}")

                user_pattern = regex_input.value.strip() if regex_input.value.strip() else None
                regex_tool(df, selected_column, user_pattern)
            else:
                display("Please load a valid CSV file and select a column.")
        except Exception as e:
            display(f"An error occurred: {str(e)}")

# Attach the function to the run button
run_button.on_click(run_regex_tool)
