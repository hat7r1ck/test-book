# Import necessary libraries
import re
import random
import numpy as np
import pandas as pd
from IPython.display import display, Markdown
import ipywidgets as widgets
from ipyfilechooser import FileChooser

# Placeholder for the DataFrame
df = None

# UI Components
style = {'description_width': 'initial'}
layout = widgets.Layout(width='50%')
button_layout = widgets.Layout(width='20%')

# File chooser widget
file_chooser = FileChooser(
    use_dir_icons=True,
    filter_pattern='*.csv',
    show_only_dirs=False
)

# Button to load CSV
load_button = widgets.Button(
    description="Load CSV",
    layout=button_layout,
    button_style='primary'
)

# Column selector widget
column_selector = widgets.Dropdown(
    options=[],  # To be populated with column names after loading CSV
    description="Select Column:",
    style=style,
    layout=layout,
    disabled=True  # Disabled until CSV is loaded
)

# Label selector widget
label_selector = widgets.Dropdown(
    options=[],  # To be populated with label column names after loading CSV
    description="Select Label Column:",
    style=style,
    layout=layout,
    disabled=True  # Disabled until CSV is loaded
)

# Button to trigger the regex tool
run_button = widgets.Button(
    description="Run Regex Generator",
    layout=button_layout,
    button_style='success'
)

# Output area for displaying messages
output = widgets.Output()

# Display the widgets in a vertical box
display(widgets.VBox([
    file_chooser,
    load_button,
    column_selector,
    label_selector,
    run_button,
    output
]))

# Function to load CSV from selected file
def load_csv(b):
    global df
    with output:
        output.clear_output()
        file_path = file_chooser.selected
        if not file_path:
            display("Please select a CSV file.")
            return
        try:
            display(f"Loading CSV file from: {file_path}")
            df = pd.read_csv(file_path)
            display("CSV file content preview:")
            display(df.head())  # Show a preview of the DataFrame
            # Populate the column selectors with the DataFrame's columns
            column_selector.options = df.columns.tolist()
            column_selector.disabled = False  # Enable the column selector
            label_selector.options = df.columns.tolist()
            label_selector.disabled = False  # Enable the label selector
            run_button.disabled = False
            display("CSV file loaded successfully. Select columns from the dropdowns.")
        except Exception as e:
            display(f"Error loading CSV file: {str(e)}")

# Attach the function to the load button
load_button.on_click(load_csv)

# Genetic Algorithm for Regex Generation
class RegexGeneticAlgorithm:
    def __init__(self, positive_samples, negative_samples, population_size=50, generations=50,
                 crossover_rate=0.7, mutation_rate=0.1, elitism_count=2):
        self.positive_samples = positive_samples
        self.negative_samples = negative_samples
        self.population_size = population_size
        self.generations = generations
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.elitism_count = elitism_count
        self.population = []
        self.char_set = self.get_char_set()
        self.regex_elements = self.get_regex_elements()
        self.best_pattern = ''
        self.best_fitness = -float('inf')

    def get_char_set(self):
        # Extract all unique characters from positive samples
        chars = set(''.join(self.positive_samples))
        return chars

    def get_regex_elements(self):
        # Define possible regex elements based on the character set
        elements = []
        for c in self.char_set:
            elements.append(re.escape(c))
        elements.extend(['.', '\d', '\w', '\s'])
        return elements

    def initialize_population(self):
        # Generate initial population of random regex patterns
        for _ in range(self.population_size):
            pattern_length = random.randint(3, 10)
            pattern = ''.join(random.choices(self.regex_elements, k=pattern_length))
            self.population.append(pattern)

    def fitness(self, pattern):
        try:
            regex = re.compile('^' + pattern + '$')
        except re.error:
            return -float('inf')  # Invalid regex patterns are least fit

        tp = sum(bool(regex.match(s)) for s in self.positive_samples)
        fp = sum(bool(regex.match(s)) for s in self.negative_samples)

        tpr = tp / len(self.positive_samples) if self.positive_samples else 0
        fpr = fp / len(self.negative_samples) if self.negative_samples else 0

        # Fitness function balancing TPR and FPR
        fitness_score = tpr - fpr

        # Penalize overly general patterns
        if fpr > 0:
            fitness_score -= fpr

        # Prefer shorter patterns
        fitness_score -= len(pattern) * 0.01

        return fitness_score

    def selection(self):
        # Tournament selection
        selected = []
        for _ in range(self.population_size):
            participants = random.sample(self.population, k=3)
            participant_fitness = [(p, self.fitness(p)) for p in participants]
            winner = max(participant_fitness, key=lambda x: x[1])
            selected.append(winner[0])
        return selected

    def crossover(self, parent1, parent2):
        # Single-point crossover
        if random.random() < self.crossover_rate:
            point = random.randint(1, min(len(parent1), len(parent2)) - 1)
            child1 = parent1[:point] + parent2[point:]
            child2 = parent2[:point] + parent1[point:]
            return [child1, child2]
        else:
            return [parent1, parent2]

    def mutate(self, pattern):
        # Random mutation
        pattern_list = list(pattern)
        for i in range(len(pattern_list)):
            if random.random() < self.mutation_rate:
                pattern_list[i] = random.choice(self.regex_elements)
        return ''.join(pattern_list)

    def run(self):
        self.initialize_population()
        for generation in range(self.generations):
            new_population = []

            # Evaluate fitness and keep the best patterns (elitism)
            population_fitness = [(p, self.fitness(p)) for p in self.population]
            population_fitness.sort(key=lambda x: x[1], reverse=True)
            if population_fitness[0][1] > self.best_fitness:
                self.best_fitness = population_fitness[0][1]
                self.best_pattern = population_fitness[0][0]
            elites = [p for p, _ in population_fitness[:self.elitism_count]]
            new_population.extend(elites)

            # Selection
            selected = self.selection()

            # Generate new population through crossover and mutation
            while len(new_population) < self.population_size:
                parents = random.sample(selected, 2)
                offspring = self.crossover(parents[0], parents[1])
                offspring = [self.mutate(child) for child in offspring]
                new_population.extend(offspring)

            self.population = new_population[:self.population_size]

            # Optional: Print progress
            # print(f"Generation {generation + 1}, Best Fitness: {self.best_fitness}, Best Pattern: {self.best_pattern}")

        return self.best_pattern

# Function to trigger the regex generator when the button is clicked
def run_regex_generator(b):
    with output:
        output.clear_output()
        try:
            if df is not None and column_selector.value and label_selector.value:
                selected_column = column_selector.value
                label_column = label_selector.value
                data_column = df[selected_column].astype(str)
                labels = df[label_column]

                positive_samples = data_column[labels == 1].tolist()
                negative_samples = data_column[labels == 0].tolist()

                if not positive_samples:
                    display("No positive samples found. Please ensure your label column contains '1' for desired matches.")
                    return

                ga = RegexGeneticAlgorithm(
                    positive_samples=positive_samples,
                    negative_samples=negative_samples,
                    population_size=50,
                    generations=50,
                    crossover_rate=0.7,
                    mutation_rate=0.1,
                    elitism_count=2
                )

                best_pattern = ga.run()
                regex_pattern = '^' + best_pattern + '$'

                # Evaluate final pattern
                regex = re.compile(regex_pattern)
                tp = sum(bool(regex.match(s)) for s in positive_samples)
                fp = sum(bool(regex.match(s)) for s in negative_samples)
                fn = len(positive_samples) - tp
                tn = len(negative_samples) - fp

                tpr = tp / len(positive_samples) if positive_samples else 0
                fpr = fp / len(negative_samples) if negative_samples else 0

                display(Markdown(f"**Generated Regex Pattern:** `{regex_pattern}`"))
                display(Markdown(f"**True Positives:** {tp}"))
                display(Markdown(f"**False Positives:** {fp}"))
                display(Markdown(f"**True Negatives:** {tn}"))
                display(Markdown(f"**False Negatives:** {fn}"))
                display(Markdown(f"**True Positive Rate (TPR):** {tpr:.2f}"))
                display(Markdown(f"**False Positive Rate (FPR):** {fpr:.2f}"))

                # Display matched and unmatched samples
                display(Markdown("**Examples of Positive Samples Matched:**"))
                matched_positives = [s for s in positive_samples if regex.match(s)]
                display(matched_positives[:5])

                display(Markdown("**Examples of Negative Samples Matched (False Positives):**"))
                matched_negatives = [s for s in negative_samples if regex.match(s)]
                display(matched_negatives[:5])

            else:
                display("Please load a valid CSV file and select the data and label columns.")
        except Exception as e:
            display(f"An error occurred: {str(e)}")

# Attach the function to the run button
run_button.on_click(run_regex_generator)
