# Import necessary libraries
import re
import pandas as pd
from IPython.display import display, HTML, Markdown
import Levenshtein
import time
import ipywidgets as widgets
import io
from os import path
from difflib import SequenceMatcher
from ipyfilechooser import FileChooser

# Placeholder for the dataframe
df = None

# File chooser widget
file_chooser = FileChooser(
    use_dir_icons=True,
    filter_pattern='*.csv',
    show_only_dirs=False
)

# Button to load CSV
load_button = widgets.Button(
    description="Load CSV",
    button_style='primary',
    layout=widgets.Layout(width='20%'),
)

# Display the widgets
display(file_chooser)
display(load_button)
display(column_selector)
display(Markdown("**Optional:** You may provide a custom regex pattern or select one from the library..."))
display(regex_library_selector)
display(regex_input)
display(run_button)
display(output)

# Function to trigger the regex tool when the button is clicked
def run_regex_tool(b):
    with output:
        output.clear_output()  # Clear previous messages
        try:
            if df is not None and column_selector.value:
                selected_column = column_selector.value
                display(f"Running regex tool on column: {selected_column}")
                
                user_pattern = None
                if regex_input.value.strip():
                    user_pattern = regex_input.value.strip()
                elif regex_library_selector.value != '-- Select from Library --':
                    user_pattern = regex_input.value.strip()
                
                regex_tool(df, selected_column, user_pattern)
            else:
                if df is None:
                    display("Please upload a valid CSV file.")
                else:
                    display("Please select a column from the dropdown.")
        except Exception as e:
            display(f"An error occurred: {str(e)}")


# Attach the function to the load button
load_button.on_click(load_csv)

# Update the button state based on column selection
def handle_column_selection(change):
    with output:
        output.clear_output()
        if column_selector.value:
            run_button.disabled = False  # Enable the run button
            display(f"Column '{column_selector.value}' selected. You can now run the regex tool.")
        else:
            run_button.disabled = True

# Attach the column selection observer
column_selector.observe(handle_column_selection, names='value')

# Update regex_input based on library selection
def handle_regex_library_selection(change):
    if regex_library_selector.value != '-- Select from Library --':
        regex_input.value = built_in_regex_library[regex_library_selector.value]
    else:
        regex_input.value = ''

regex_library_selector.observe(handle_regex_library_selection, names='value')

# Feature: Context-Aware Regex Suggestions (tree-based analysis for substrings, prefixes, suffixes)
def generate_optimized_regex(column_data):
    # Identify common substrings, prefixes, and suffixes

    # Find the longest common substring among all the data in the column
    def longest_common_substring(data):
        substr = ''
        if len(data) > 1 and len(data[0]) > 0:
            substr = data[0]
            for s in data[1:]:
                match = SequenceMatcher(None, substr, s).find_longest_match(0, len(substr), 0, len(s))
                substr = substr[match.a: match.a + match.size]
                if not substr:
                    break
        return substr

    # Find common prefix
    def common_prefix(strings):
        if not strings:
            return ''
        prefix = strings[0]
        for s in strings[1:]:
            prefix = path.commonprefix([prefix, s])
            if not prefix:
                break
        return prefix

    # Find common suffix
    def common_suffix(strings):
        if not strings:
            return ''
        reversed_strings = [s[::-1] for s in strings]
        reversed_suffix = common_prefix(reversed_strings)
        return reversed_suffix[::-1]

    data_list = column_data.tolist()
    prefix = common_prefix(data_list)
    suffix = common_suffix(data_list)
    substring = longest_common_substring(data_list)

    # Build regex pattern
    pattern = ''
    if prefix:
        pattern += re.escape(prefix)
        pattern += '.*'
    if substring and substring not in prefix and substring not in suffix:
        pattern += re.escape(substring)
        pattern += '.*'
    if suffix and suffix not in prefix:
        pattern += re.escape(suffix)

    if not pattern:
        # If no commonality is found, return a pattern that matches any string
        pattern = '.*'

    return pattern

# Feature: Regex Performance Metrics
def measure_performance(pattern, data):
    start_time = time.time()
    matches = [re.search(pattern, value) for value in data]
    end_time = time.time()
    processing_time = end_time - start_time
    match_count = sum([1 for match in matches if match])
    return {
        "processing_time": processing_time,
        "match_count": match_count,
        "coverage_percentage": (match_count / len(data)) * 100
    }

# Feature: Built-in Regex Library (common regex patterns)
built_in_regex_library = {
    # ... [Your regex patterns as before] ...
}

# Update regex_library_selector options
regex_library_selector.options = ['-- Select from Library --'] + list(built_in_regex_library.keys())

# Feature: Pattern History & Versioning
pattern_history = []

def save_pattern_version(pattern):
    pattern_history.append(pattern)

# Feature: Regex Debugger (step-by-step matching)
def debug_regex(pattern, data):
    for value in data:
        match = re.search(pattern, value)
        if match:
            print(f"Value: {value} --> Matched: {match.group(0)}")
        else:
            print(f"Value: {value} --> No Match")

# Feature: Levenshtein-based approximate matching
def levenshtein_approximate_match(data, pattern, threshold=0.8):
    matched, unmatched = [], []
    for value in data:
        ratio = Levenshtein.ratio(value, pattern)
        if ratio >= threshold:
            matched.append(value)
        else:
            unmatched.append(value)
    return matched, unmatched

# Sandbox Feature: Safe environment for testing regex patterns
def sandbox_environment(pattern, test_data):
    print("Testing Regex in Sandbox Environment:")
    debug_regex(pattern, test_data)

def provide_feedback(data, pattern):
    matched = [row for row in data if re.search(pattern, row)]
    unmatched = [row for row in data if not re.search(pattern, row)]
    
    match_percentage = len(matched) / len(data) * 100
    feedback = f"Match Percentage: {match_percentage:.2f}%\n"
    
    if match_percentage < 80:
        feedback += "Suggestions:\n"
        feedback += "- Consider refining the pattern or reviewing unmatched data for inconsistencies.\n"
    
    return feedback, matched, unmatched

def explain_regex(pattern):
    explanation = []
    if re.search(r'\d', pattern):
        explanation.append("Matches digit characters (0-9).")
    if re.search(r'\w', pattern):
        explanation.append("Matches word characters (a-z, A-Z, 0-9, _).")
    if re.search(r'\s', pattern):
        explanation.append("Matches whitespace characters.")
    if re.search(r'\b', pattern):
        explanation.append("Matches word boundaries.")
    if re.search(r'[A-Z]', pattern):
        explanation.append("Matches uppercase letters.")
    if re.search(r'[a-z]', pattern):
        explanation.append("Matches lowercase letters.")
    if re.search(r'\.', pattern):
        explanation.append("Matches any character.")
    # Add more explanations as needed
    return "\n".join(explanation)

# Interactive buttons for pattern adjustment and copying to clipboard
def interactive_buttons(optimized_pattern):
    display(Markdown(f"**Regex Pattern:** `{optimized_pattern}`"))
    # Provide alternative instructions if the button doesn't work
    display(Markdown("Copy the regex pattern manually if the button doesn't work."))

# Define the main function to integrate all the functionality
def regex_tool(data, column_name, user_pattern=None, threshold=0.8):
    column_data = data[column_name].astype(str)
    
    # Generate optimized regex automatically
    auto_generated_pattern = generate_optimized_regex(column_data)
    
    # Determine which pattern to use
    if user_pattern:
        initial_pattern = user_pattern
        pattern_source = "User-provided pattern"
    else:
        initial_pattern = auto_generated_pattern
        pattern_source = "Automatically generated pattern"

    # Save pattern version
    save_pattern_version(initial_pattern)
    
    # Measure performance
    performance_metrics = measure_performance(initial_pattern, column_data)
    
    # Provide feedback based on initial pattern
    feedback, matched, unmatched = provide_feedback(column_data, initial_pattern)
    
    # Generate interactive output
    display(Markdown(f"**{pattern_source}:** `{initial_pattern}`"))
    display(Markdown(f"**Regex Explanation:**\n{explain_regex(initial_pattern)}"))
    display(Markdown(f"**Matched Rows:** {len(matched)}"))
    display(Markdown(f"**Unmatched Rows:** {len(unmatched)}"))
    display(Markdown(f"**Feedback:**\n{feedback}"))
    display(Markdown(f"**Performance Metrics:**"))
    display(Markdown(f"- Processing Time: {performance_metrics['processing_time']:.4f} seconds"))
    display(Markdown(f"- Matches: {performance_metrics['match_count']}"))
    display(Markdown(f"- Coverage: {performance_metrics['coverage_percentage']:.2f}%"))
    
    # If a user pattern was provided, offer the auto-generated pattern as a suggestion
    if user_pattern:
        display(Markdown(f"**Auto-Generated Pattern Suggestion:** `{auto_generated_pattern}`"))
        display(Markdown(f"**Auto-Generated Pattern Explanation:**\n{explain_regex(auto_generated_pattern)}"))
        # Interactive adjustment buttons
        interactive_buttons(auto_generated_pattern)
    else:
        # Interactive adjustment buttons
        interactive_buttons(initial_pattern)
    
    # Levenshtein approximate matching suggestions
    if len(unmatched) > 0:
        approx_matched, approx_unmatched = levenshtein_approximate_match(unmatched, initial_pattern, threshold)
        display(Markdown(f"**Approximate Matching:**\n"))
        display(Markdown(f"Matched via Levenshtein (Threshold {threshold}): {len(approx_matched)}\n"))
        display(Markdown(f"Remaining Unmatched: {len(approx_unmatched)}"))
    
    # Sandbox feature
    sandbox_environment(initial_pattern, unmatched)

# Function to trigger the regex tool when the button is clicked
def run_regex_tool(b):
    with output:
        output.clear_output()  # Clear previous messages
        try:
            if df is not None and column_selector.value:
                selected_column = column_selector.value
                display(f"Running regex tool on column: {selected_column}")
                
                user_pattern = None
                if regex_input.value.strip():
                    user_pattern = regex_input.value.strip()
                elif regex_library_selector.value != '-- Select from Library --':
                    user_pattern = regex_input.value.strip()
                
                regex_tool(df, selected_column, user_pattern)
            else:
                if df is None:
                    display("Please upload a valid CSV file.")
                else:
                    display("Please select a column from the dropdown.")
        except Exception as e:
            display(f"An error occurred: {str(e)}")

# Attach the function to the button
run_button.on_click(run_regex_tool)
