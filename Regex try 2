# Import necessary libraries
import re
import pandas as pd
from IPython.display import display, HTML, Markdown
import Levenshtein
import time
import ipywidgets as widgets
import io
from os import path
from ipyfilechooser import FileChooser
import string
from collections import Counter

# Placeholder for the DataFrame
df = None

# File chooser widget
file_chooser = FileChooser(
    use_dir_icons=True,
    filter_pattern='*.csv',
    show_only_dirs=False
)

# Button to load CSV
load_button = widgets.Button(
    description="Load CSV",
    button_style='primary',
    layout=widgets.Layout(width='20%'),
)

# Column selector widget with width adjustment for better visibility
column_selector = widgets.Dropdown(
    options=[],  # To be populated with column names after loading CSV
    description="Select Column:",
    style={'description_width': 'initial'},
    layout=widgets.Layout(width='50%'),
    disabled=True  # Disabled until CSV is loaded
)

# Regex Library Selector
regex_library_selector = widgets.Dropdown(
    options=['-- Select from Library --'],  # Will be populated later
    description="Regex Library (Optional):",
    style={'description_width': 'initial'},
    layout=widgets.Layout(width='50%'),
)

# Text input widget for the regex pattern
regex_input = widgets.Text(
    value='',
    description='Custom Regex Pattern (Optional):',
    style={'description_width': 'initial'},
    layout=widgets.Layout(width='50%'),
)

# Button to trigger the regex tool
run_button = widgets.Button(
    description="Run Regex Tool",
    button_style='success',
    layout=widgets.Layout(width='20%'),
    disabled=True  # Will be enabled after column selection
)

# Output area for displaying messages
output = widgets.Output()

# Display the widgets
display(file_chooser)
display(load_button)
display(column_selector)
display(Markdown("**Optional:** You may provide a custom regex pattern or select one from the library..."))
display(regex_library_selector)
display(regex_input)
display(run_button)
display(output)

# Feature: Built-in Regex Library (common regex patterns)
built_in_regex_library = {
    # Add your regex patterns here
    'Email Address': r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}',
    # ... (other patterns as needed)
}

# Update regex_library_selector options
regex_library_selector.options = ['-- Select from Library --'] + list(built_in_regex_library.keys())

# Function to update regex_input based on library selection
def handle_regex_library_selection(change):
    if regex_library_selector.value != '-- Select from Library --':
        regex_input.value = built_in_regex_library[regex_library_selector.value]
    else:
        regex_input.value = ''

regex_library_selector.observe(handle_regex_library_selection, names='value')

# Function to load CSV from selected file
def load_csv(b):
    global df
    with output:
        output.clear_output()
        file_path = file_chooser.selected
        if not file_path:
            display("Please select a CSV file.")
            return
        try:
            display(f"Loading CSV file from: {file_path}")
            df = pd.read_csv(file_path)
            display("CSV file content preview:")
            # Display the DataFrame in a scrollable output
            from IPython.display import HTML

            # Convert the DataFrame to HTML with scrollable styling
            def display_scrollable_dataframe(df):
                html = df.to_html()
                scrollable_div = f'''
                <div style="overflow-x: auto; max-width: 100%;">
                    {html}
                </div>
                '''
                display(HTML(scrollable_div))

            display_scrollable_dataframe(df.head())  # Show a preview of the DataFrame
            # Populate the column selector with the DataFrame's columns
            column_selector.options = df.columns.tolist()
            column_selector.disabled = False  # Enable the column selector
            run_button.disabled = True  # Disable the run button until a column is selected
            display("CSV file loaded successfully. Select a column from the dropdown.")
        except Exception as e:
            display(f"Error loading CSV file: {str(e)}")

# Attach the function to the load button
load_button.on_click(load_csv)

# Update the button state based on column selection
def handle_column_selection(change):
    with output:
        output.clear_output()
        if column_selector.value:
            run_button.disabled = False  # Enable the run button
            display(f"Column '{column_selector.value}' selected. You can now run the regex tool.")
        else:
            run_button.disabled = True

# Attach the column selection observer
column_selector.observe(handle_column_selection, names='value')

# Feature: Pattern History & Versioning
pattern_history = []

def save_pattern_version(pattern):
    pattern_history.append(pattern)

# Function to explain regex patterns
def explain_regex(pattern):
    explanation = []
    # Simple explanations for basic regex components
    if '^' in pattern:
        explanation.append("`^`: Matches the start of the string.")
    if '$' in pattern:
        explanation.append("`$`: Matches the end of the string.")
    if r'\d' in pattern:
        explanation.append(r"`\d`: Matches any digit (0-9).")
    if r'\w' in pattern:
        explanation.append(r"`\w`: Matches any word character (letters, digits, underscore).")
    if r'\s' in pattern:
        explanation.append(r"`\s`: Matches any whitespace character.")
    if '.' in pattern and not r'\.' in pattern:
        explanation.append("`. (dot)`: Matches any character except newline.")
    if '+' in pattern:
        explanation.append("`+`: Matches 1 or more of the preceding element.")
    if '*' in pattern:
        explanation.append("`*`: Matches 0 or more of the preceding element.")
    if '?' in pattern:
        explanation.append("`?`: Matches 0 or 1 of the preceding element.")
    if '[' in pattern and ']' in pattern:
        explanation.append("`[...]`: Character class, matches any one of the characters inside the brackets.")
    if '{' in pattern and '}' in pattern:
        explanation.append("`{m,n}`: Quantifier, matches between m and n occurrences of the preceding element.")
    # Add more explanations as needed
    return "\n".join(explanation)

# Feature: Levenshtein-based approximate matching
def levenshtein_approximate_match(unmatched_data, matched_data, threshold=0.8):
    matched, unmatched = [], []
    for value in unmatched_data:
        # Find the closest match in matched_data
        closest_similarity = 0
        for match_value in matched_data:
            distance = Levenshtein.distance(value, match_value)
            max_len = max(len(value), len(match_value))
            similarity = 1 - (distance / max_len) if max_len > 0 else 0
            if similarity > closest_similarity:
                closest_similarity = similarity
        if closest_similarity >= threshold:
            matched.append(value)
        else:
            unmatched.append(value)
    return matched, unmatched

# Sandbox Feature: Safe environment for testing regex patterns
def sandbox_environment(pattern, test_data):
    display(Markdown("**Testing Regex in Sandbox Environment:**"))
    for value in test_data[:5]:  # Limit output to first 5 entries
        match = re.fullmatch(pattern, value)
        if match:
            display(f"Value: {value} --> Matched: {match.group(0)}")
        else:
            display(f"Value: {value} --> No Match")

def provide_feedback(data, pattern):
    matched = [row for row in data if re.fullmatch(pattern, row)]
    unmatched = [row for row in data if not re.fullmatch(pattern, row)]

    match_percentage = len(matched) / len(data) * 100 if len(data) > 0 else 0
    feedback = f"Match Percentage: {match_percentage:.2f}%\n"

    if match_percentage < 80:
        feedback += "Suggestions:\n"
        feedback += "- Consider refining the pattern or reviewing unmatched data for inconsistencies.\n"

    return feedback, matched, unmatched

# Interactive buttons for pattern adjustment and copying to clipboard
def interactive_buttons(optimized_pattern):
    display(Markdown(f"**Regex Pattern:** `{optimized_pattern}`"))
    # Provide alternative instructions if the button doesn't work
    display(Markdown("Copy the regex pattern manually if the button doesn't work."))

# Enhanced regex generator function
def generate_smart_regex(column_data, min_substring_length=3, min_occurrence_ratio=0.5, max_pattern_length=200):
    unique_values = [s for s in set(column_data) if s]
    if not unique_values:
        return '.*'  # Return a generic pattern if data is empty

    substring_counter = Counter()
    total_strings = len(unique_values)

    # Build substring counter
    for s in unique_values:
        length = len(s)
        substrings = set()
        for i in range(length):
            for j in range(i + min_substring_length, min(length + 1, i + min_substring_length + 10)):
                substr = s[i:j]
                substrings.add(substr)
        substring_counter.update(substrings)

    # Filter substrings that occur in at least min_occurrence_ratio of strings
    common_substrings = []
    for substr, count in substring_counter.items():
        if count / total_strings >= min_occurrence_ratio:
            common_substrings.append((substr, count))

    # Sort substrings by length and frequency
    common_substrings.sort(key=lambda x: (-len(x[0]), -x[1]))

    # Build the regex
    if not common_substrings:
        # Fallback to generic pattern if no common substrings found
        return '^.{%d,%d}$' % (min(len(s) for s in unique_values), max(len(s) for s in unique_values))

    # Use the longest common substrings (up to 3)
    substrings_to_use = [s[0] for s in common_substrings[:3]]
    pattern = '.*'.join(map(re.escape, substrings_to_use))
    pattern = '^.*' + pattern + '.*$'

    # Ensure pattern is not too long
    if len(pattern) > max_pattern_length:
        # Generalize if pattern is too long
        pattern = '^.{%d,%d}$' % (min(len(s) for s in unique_values), max(len(s) for s in unique_values))

    return pattern

# Define the main function to integrate all the functionality
def regex_tool(data, column_name, user_pattern=None, threshold=0.8):
    column_data = data[column_name].astype(str)

    # Generate the regex pattern using the improved function
    auto_generated_pattern = generate_smart_regex(column_data)

    # Determine which pattern to use
    if user_pattern:
        initial_pattern = user_pattern
        pattern_source = "User-provided pattern"
    else:
        initial_pattern = auto_generated_pattern
        pattern_source = "Automatically generated pattern"

    # Save pattern version
    save_pattern_version(initial_pattern)

    # Measure performance
    performance_metrics = measure_performance(initial_pattern, column_data)

    # Provide feedback based on initial pattern
    feedback, matched, unmatched = provide_feedback(column_data, initial_pattern)

    # Generate interactive output
    display(Markdown(f"**{pattern_source}:** `{initial_pattern}`"))
    display(Markdown(f"**Regex Explanation:**\n{explain_regex(initial_pattern)}"))
    display(Markdown(f"**Matched Rows:** {len(matched)}"))
    display(Markdown(f"**Unmatched Rows:** {len(unmatched)}"))
    display(Markdown(f"**Feedback:**\n{feedback}"))
    display(Markdown(f"**Performance Metrics:**"))
    display(Markdown(f"- Processing Time: {performance_metrics['processing_time']:.4f} seconds"))
    display(Markdown(f"- Matches: {performance_metrics['match_count']}"))
    display(Markdown(f"- Coverage: {performance_metrics['coverage_percentage']:.2f}%"))

    # If a user pattern was provided, offer the auto-generated pattern as a suggestion
    if user_pattern:
        display(Markdown(f"**Auto-Generated Pattern Suggestion:** `{auto_generated_pattern}`"))
        display(Markdown(f"**Auto-Generated Pattern Explanation:**\n{explain_regex(auto_generated_pattern)}"))
        # Interactive adjustment buttons
        interactive_buttons(auto_generated_pattern)
    else:
        # Interactive adjustment buttons
        interactive_buttons(initial_pattern)

    # Levenshtein approximate matching suggestions
    if len(unmatched) > 0 and len(matched) > 0:
        approx_matched, approx_unmatched = levenshtein_approximate_match(unmatched, matched, threshold)
        display(Markdown(f"**Approximate Matching:**\n"))
        display(Markdown(f"Matched via Levenshtein (Threshold {threshold}): {len(approx_matched)}\n"))
        display(Markdown(f"Remaining Unmatched: {len(approx_unmatched)}"))
    else:
        display(Markdown("**No approximate matches could be found.**"))

    # Sandbox feature
    if len(unmatched) > 0:
        sandbox_environment(initial_pattern, unmatched)

# Function to measure regex performance
def measure_performance(pattern, data):
    start_time = time.time()
    try:
        compiled_pattern = re.compile(pattern)
        matches = [compiled_pattern.fullmatch(value) for value in data]
    except re.error as e:
        end_time = time.time()
        return {
            "processing_time": end_time - start_time,
            "match_count": 0,
            "coverage_percentage": 0,
            "error": str(e)
        }
    end_time = time.time()
    processing_time = end_time - start_time
    match_count = sum(1 for match in matches if match)
    coverage_percentage = (match_count / len(data)) * 100 if len(data) > 0 else 0
    return {
        "processing_time": processing_time,
        "match_count": match_count,
        "coverage_percentage": coverage_percentage
    }

# Function to trigger the regex tool when the button is clicked
def run_regex_tool(b):
    with output:
        output.clear_output()  # Clear previous messages
        try:
            if df is not None and column_selector.value:
                selected_column = column_selector.value
                display(f"Running regex tool on column: {selected_column}")

                user_pattern = None
                if regex_input.value.strip():
                    user_pattern = regex_input.value.strip()
                elif regex_library_selector.value != '-- Select from Library --':
                    user_pattern = regex_input.value.strip()

                regex_tool(df, selected_column, user_pattern)
            else:
                if df is None:
                    display("Please load a valid CSV file.")
                else:
                    display("Please select a column from the dropdown.")
        except Exception as e:
            display(f"An error occurred: {str(e)}")

# Attach the function to the run button
run_button.on_click(run_regex_tool)
