# Import necessary libraries
import re
import random
import numpy as np
import pandas as pd
from IPython.display import display, Markdown
import ipywidgets as widgets

# Placeholder for the DataFrame
df = None

# UI Components
style = {'description_width': 'initial'}
layout = widgets.Layout(width='50%')
button_layout = widgets.Layout(width='20%')

# File upload widget
file_upload = widgets.FileUpload(
    accept='.csv',  # Accepts CSV files
    multiple=False,
    description='Upload CSV File',
    style=style,
    layout=layout
)

# Button to load CSV
load_button = widgets.Button(
    description="Load CSV",
    layout=button_layout,
    button_style='primary',
    disabled=True  # Initially disabled until a file is uploaded
)

# Column selector widget
column_selector = widgets.Dropdown(
    options=[],  # To be populated with column names after loading CSV
    description="Select Data Column:",
    style=style,
    layout=layout,
    disabled=True  # Disabled until CSV is loaded
)

# Label selector widget
label_selector = widgets.Dropdown(
    options=[],  # To be populated with label column names after loading CSV
    description="Select Label Column:",
    style=style,
    layout=layout,
    disabled=True  # Disabled until CSV is loaded
)

# Positive label value input
positive_label_input = widgets.Text(
    value='',
    description='Positive Label Value:',
    style=style,
    layout=layout,
    placeholder='Enter the label value for positive samples',
    disabled=True  # Disabled until columns are selected
)

# Button to trigger the regex tool
run_button = widgets.Button(
    description="Run Regex Generator",
    layout=button_layout,
    button_style='success',
    disabled=True  # Disabled until all inputs are provided
)

# Output area for displaying messages
output = widgets.Output()

# Display the widgets in a vertical box
display(widgets.VBox([
    widgets.HTML("<h2>Regex Pattern Generator</h2>"),
    file_upload,
    load_button,
    column_selector,
    label_selector,
    positive_label_input,
    run_button,
    output
]))

# Function to enable the load button when a file is uploaded
def on_file_upload_change(change):
    if file_upload.value:
        load_button.disabled = False
    else:
        load_button.disabled = True

file_upload.observe(on_file_upload_change, names='value')

# Function to load CSV from uploaded file
def load_csv(b):
    global df
    with output:
        output.clear_output()
        if not file_upload.value:
            display(Markdown("**Please upload a CSV file.**"))
            return
        try:
            uploaded_file = list(file_upload.value.values())[0]
            content = uploaded_file['content']
            df = pd.read_csv(pd.io.common.BytesIO(content))
            display(Markdown("**CSV file content preview:**"))
            display(df.head())  # Show a preview of the DataFrame

            # Populate the column selectors with the DataFrame's columns
            column_selector.options = df.columns.tolist()
            label_selector.options = df.columns.tolist()

            # Enable the column selectors
            column_selector.disabled = False
            label_selector.disabled = False

            display(Markdown("**CSV file loaded successfully.**"))
            display(Markdown("**Please select the data and label columns from the dropdowns.**"))
        except Exception as e:
            display(Markdown(f"**Error loading CSV file:** `{str(e)}`"))

# Attach the function to the load button
load_button.on_click(load_csv)

# Enable the positive label input when columns are selected
def on_columns_selected(change):
    if column_selector.value and label_selector.value:
        positive_label_input.disabled = False
    else:
        positive_label_input.disabled = True
    enable_run_button(None)

column_selector.observe(on_columns_selected, names='value')
label_selector.observe(on_columns_selected, names='value')

# Enable the run button when all inputs are provided
def enable_run_button(change):
    if column_selector.value and label_selector.value and positive_label_input.value.strip():
        run_button.disabled = False
    else:
        run_button.disabled = True

positive_label_input.observe(enable_run_button, names='value')

# Genetic Algorithm for Regex Generation
class RegexGeneticAlgorithm:
    def __init__(self, positive_samples, negative_samples, population_size=50, generations=50,
                 crossover_rate=0.7, mutation_rate=0.1, elitism_count=2):
        self.positive_samples = positive_samples
        self.negative_samples = negative_samples
        self.population_size = population_size
        self.generations = generations
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.elitism_count = elitism_count
        self.population = []
        self.char_set = self.get_char_set()
        self.regex_elements = self.get_regex_elements()
        self.best_pattern = ''
        self.best_fitness = -float('inf')

    def get_char_set(self):
        # Extract all unique characters from positive samples
        chars = set(''.join(self.positive_samples))
        return chars

    def get_regex_elements(self):
        # Define possible regex elements based on the character set
        elements = []
        for c in self.char_set:
            elements.append(re.escape(c))
        elements.extend(['.', '\d', '\w', '\s'])
        return elements

    def initialize_population(self):
        # Generate initial population of random regex patterns
        for _ in range(self.population_size):
            pattern_length = random.randint(3, 10)
            pattern = ''.join(random.choices(self.regex_elements, k=pattern_length))
            self.population.append(pattern)

    def fitness(self, pattern):
        try:
            regex = re.compile('^' + pattern + '$')
        except re.error:
            return -float('inf')  # Invalid regex patterns are least fit

        tp = sum(bool(regex.fullmatch(s)) for s in self.positive_samples)
        fp = sum(bool(regex.fullmatch(s)) for s in self.negative_samples)

        tpr = tp / len(self.positive_samples) if self.positive_samples else 0
        fpr = fp / len(self.negative_samples) if self.negative_samples else 0

        # Fitness function balancing TPR and FPR
        fitness_score = tpr - fpr

        # Penalize overly general patterns
        if fpr > 0:
            fitness_score -= fpr

        # Prefer shorter patterns
        fitness_score -= len(pattern) * 0.01

        return fitness_score

    def selection(self):
        # Tournament selection
        selected = []
        for _ in range(self.population_size):
            participants = random.sample(self.population, k=3)
            participant_fitness = [(p, self.fitness(p)) for p in participants]
            winner = max(participant_fitness, key=lambda x: x[1])
            selected.append(winner[0])
        return selected

    def crossover(self, parent1, parent2):
        # Single-point crossover
        if random.random() < self.crossover_rate and min(len(parent1), len(parent2)) > 1:
            point = random.randint(1, min(len(parent1), len(parent2)) - 1)
            child1 = parent1[:point] + parent2[point:]
            child2 = parent2[:point] + parent1[point:]
            return [child1, child2]
        else:
            return [parent1, parent2]

    def mutate(self, pattern):
        # Random mutation
        pattern_list = list(pattern)
        for i in range(len(pattern_list)):
            if random.random() < self.mutation_rate:
                pattern_list[i] = random.choice(self.regex_elements)
        return ''.join(pattern_list)

    def run(self):
        self.initialize_population()
        for generation in range(self.generations):
            new_population = []

            # Evaluate fitness and keep the best patterns (elitism)
            population_fitness = [(p, self.fitness(p)) for p in self.population]
            population_fitness.sort(key=lambda x: x[1], reverse=True)
            if population_fitness[0][1] > self.best_fitness:
                self.best_fitness = population_fitness[0][1]
                self.best_pattern = population_fitness[0][0]
            elites = [p for p, _ in population_fitness[:self.elitism_count]]
            new_population.extend(elites)

            # Selection
            selected = self.selection()

            # Generate new population through crossover and mutation
            while len(new_population) < self.population_size:
                parents = random.sample(selected, 2)
                offspring = self.crossover(parents[0], parents[1])
                offspring = [self.mutate(child) for child in offspring]
                new_population.extend(offspring)

            self.population = new_population[:self.population_size]

        return self.best_pattern

# Function to trigger the regex generator when the button is clicked
def run_regex_generator(b):
    with output:
        output.clear_output()
        try:
            if df is not None and column_selector.value and label_selector.value and positive_label_input.value.strip():
                selected_column = column_selector.value
                label_column = label_selector.value
                data_column = df[selected_column].astype(str)
                labels = df[label_column].astype(str)

                positive_label = positive_label_input.value.strip()
                positive_samples = data_column[labels == positive_label].tolist()
                negative_samples = data_column[labels != positive_label].tolist()

                if not positive_samples:
                    display(Markdown(f"**No positive samples found with label:** `{positive_label}`"))
                    display(Markdown("**Please ensure your label column contains the correct label value.**"))
                    unique_labels = labels.unique()
                    display(Markdown(f"**Unique label values found:** {unique_labels}"))
                    return

                ga = RegexGeneticAlgorithm(
                    positive_samples=positive_samples,
                    negative_samples=negative_samples,
                    population_size=100,
                    generations=100,
                    crossover_rate=0.7,
                    mutation_rate=0.1,
                    elitism_count=5
                )

                display(Markdown("**Running the regex generator. Please wait...**"))

                best_pattern = ga.run()
                regex_pattern = '^' + best_pattern + '$'

                # Evaluate final pattern
                regex = re.compile(regex_pattern)
                tp = sum(bool(regex.fullmatch(s)) for s in positive_samples)
                fp = sum(bool(regex.fullmatch(s)) for s in negative_samples)
                fn = len(positive_samples) - tp
                tn = len(negative_samples) - fp

                tpr = tp / len(positive_samples) if positive_samples else 0
                fpr = fp / len(negative_samples) if negative_samples else 0

                display(Markdown(f"### **Generated Regex Pattern:**"))
                display(Markdown(f"`{regex_pattern}`"))
                display(Markdown(f"**Pattern Length:** {len(regex_pattern)}"))
                display(Markdown("### **Performance Metrics:**"))
                display(Markdown(f"- **True Positives (TP):** {tp}"))
                display(Markdown(f"- **False Positives (FP):** {fp}"))
                display(Markdown(f"- **True Negatives (TN):** {tn}"))
                display(Markdown(f"- **False Negatives (FN):** {fn}"))
                display(Markdown(f"- **True Positive Rate (TPR):** {tpr:.2f}"))
                display(Markdown(f"- **False Positive Rate (FPR):** {fpr:.2f}"))

                # Display matched and unmatched samples
                display(Markdown("### **Examples of Positive Samples Matched:**"))
                matched_positives = [s for s in positive_samples if regex.fullmatch(s)]
                display(matched_positives[:5])

                display(Markdown("### **Examples of Negative Samples Matched (False Positives):**"))
                matched_negatives = [s for s in negative_samples if regex.fullmatch(s)]
                display(matched_negatives[:5])

            else:
                display(Markdown("**Please ensure all inputs are provided and valid.**"))
        except Exception as e:
            display(Markdown(f"**An error occurred:** `{str(e)}`"))

# Attach the function to the run button
run_button.on_click(run_regex_generator)
